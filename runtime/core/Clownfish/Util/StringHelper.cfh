/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

parcel Clownfish;

__C__
#include "Clownfish/Err.h"
__END_C__

inert class Clownfish::Util::StringHelper nickname StrHelp {

    /* A table where the values indicate the number of bytes in a UTF-8
     * sequence implied by the leading utf8 byte.
     */
    inert const uint8_t[] UTF8_COUNT;

    /** Return the number of bytes that two strings have in common.
     */
    inert size_t
    overlap(const char *a, const char *b, size_t a_len,  size_t b_len);

    /** Encode a NULL-terminated string representation of a value in base 36
     * into `buffer`.
     *
     * @param value The number to be encoded.
     * @param buffer A buffer at least MAX_BASE36_BYTES bytes long.
     * @return the number of digits encoded (not including the terminating
     * NULL).
     */
    inert size_t
    to_base36(uint64_t value, void *buffer);

    /** Return true if the string is valid UTF-8, false otherwise.
     */
    inert bool
    utf8_valid(const char *ptr, size_t len);

    /** Throws an error if the string isn't valid UTF-8.
     */
    inert void
    validate_utf8(const char *text, size_t size, const char *file, int line,
                  const char *func);

    /** Returns true if the code point qualifies as Unicode whitespace.
     */
    inert bool
    is_whitespace(int32_t code_point);

    /** Encode a Unicode code point to a UTF-8 sequence.
     *
     * @param code_point A legal unicode code point.
     * @param buffer Write buffer which must hold at least 4 bytes (the
     * maximum legal length for a UTF-8 char).
     */
    inert uint32_t
    encode_utf8_char(int32_t code_point, void *buffer);

    /** Return the first non-continuation byte before the supplied pointer.
     * If backtracking progresses beyond the supplied start, return NULL.
     */
    inert nullable const char*
    back_utf8_char(const char *utf8, const char *start);
}

__C__
#define CFISH_VALIDATE_UTF8(text, size) \
    cfish_StrHelp_validate_utf8(text, size, \
                                __FILE__, __LINE__, CFISH_ERR_FUNC_MACRO)

/** The maximum number of bytes encoded by to_base36(), including the
 * terminating NULL.
 */
#define cfish_StrHelp_MAX_BASE36_BYTES 14
#ifdef CFISH_USE_SHORT_NAMES
  #define StrHelp_MAX_BASE36_BYTES cfish_StrHelp_MAX_BASE36_BYTES
  #define VALIDATE_UTF8            CFISH_VALIDATE_UTF8
#endif
__END_C__


