/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

parcel Clownfish;

/** Variable-sized array.
 */
class Clownfish::VArray nickname VA inherits Clownfish::Obj {

    Obj      **elems;
    size_t     size;
    size_t     cap;

    inert incremented VArray*
    new(size_t capacity = 0);

    /**
     * @param capacity Initial number of elements that the object will be able
     * to hold before reallocation.
     */
    inert VArray*
    init(VArray *self, size_t capacity = 0);

    /** Push an item onto the end of a VArray.
     */
    void
    Push(VArray *self, decremented Obj *element = NULL);

    /** Push all the elements of another VArray onto the end of this one.
     */
    void
    Push_All(VArray *self, VArray *other);

    /** Pop an item off of the end of a VArray.
     */
    incremented nullable Obj*
    Pop(VArray *self);

    /** Insert an element at `tick` moving the following elements.
     */
    void
    Insert(VArray *self, size_t tick, decremented Obj *element = NULL);

    /** Inserts elements from `other` array at `tick` moving the following
     * elements.
     */
    void
    Insert_All(VArray *self, size_t tick, VArray *other);

    /** Ensure that the VArray has room for at least `capacity`
     * elements.
     */
    void
    Grow(VArray *self, size_t capacity);

    /** Fetch the element at `tick`.
     */
    nullable Obj*
    Fetch(VArray *self, size_t tick);

    /** Store an element at index `tick`, possibly displacing an
     * existing element.
     */
    void
    Store(VArray *self, size_t tick, decremented Obj *elem = NULL);

    /** Replace an element in the VArray with NULL and return it.
     *
     * @return whatever was stored at `tick`.
     */
    incremented nullable Obj*
    Delete(VArray *self, size_t tick);

    /** Remove `length` elements from the array, starting at
     * `offset`. Move elements over to fill in the gap.
     */
    void
    Excise(VArray *self, size_t offset, size_t length);

    /** Clone the VArray but merely increment the refcounts of its elements
     * rather than clone them.
     */
    public incremented VArray*
    Clone(VArray *self);

    /** Quicksort the VArray.
     */
    void
    Sort(VArray *self);

    /** Set the size for the VArray.  If the new size is larger than the
     * current size, grow the object to accommodate NULL elements; if smaller
     * than the current size, decrement and discard truncated elements.
     */
    void
    Resize(VArray *self, size_t size);

    /** Empty the VArray.
     */
    void
    Clear(VArray *self);

    /** Accessor for `size` member.
     */
    public size_t
    Get_Size(VArray *self);

    /** Accessor for `capacity` member.
     */
    size_t
    Get_Capacity(VArray *self);

    /** Return a new array consisting of elements from a contiguous slice.  If
     * the specified range is out of bounds, return an array with fewer
     * elements -- potentially none.
     *
     * @param offset The index of the element to start at.
     * @param length The maximum number of elements to slice.
     */
    public incremented VArray*
    Slice(VArray *self, size_t offset, size_t length);

    public bool
    Equals(VArray *self, Obj *other);

    public void
    Destroy(VArray *self);
}


