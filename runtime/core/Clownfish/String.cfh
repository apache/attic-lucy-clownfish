/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

parcel Clownfish;

__C__

// For strlen
#include <string.h>

// For CFISH_ALLOCA_OBJ.
#include "Clownfish/Class.h"

__END_C__

/**
 * Immutable string holding Unicode characters.
 */

public final class Clownfish::String nickname Str
    inherits Clownfish::Obj {

    const char *ptr;
    size_t      size;
    String     *origin;

    /** Return a String which holds a copy of the supplied UTF-8 character
     * data after checking for validity.
     */
    public inert incremented String*
    new_from_utf8(const char *utf8, size_t size);

    /** Return a String which holds a copy of the supplied UTF-8 character
     * data, skipping validity checks.
     */
    public inert incremented String*
    new_from_trusted_utf8(const char *utf8, size_t size);

    /** Initialize a String which holds a copy of the supplied UTF-8 character
     * data, skipping validity checks.
     */
    public inert String*
    init_from_trusted_utf8(String *self, const char *utf8, size_t size);

    /** Return a String which assumes ownership of the supplied buffer
     * containing UTF-8 character data after checking for validity.
     */
    public inert incremented String*
    new_steal_utf8(char *utf8, size_t size);

    /** Return a String which assumes ownership of the supplied buffer
     * containing UTF-8 character data, skipping validity checks.
     */
    public inert incremented String*
    new_steal_trusted_utf8(char *utf8, size_t size);

    /** Initialize a String which assumes ownership of the supplied buffer
     * containing UTF-8 character data, skipping validity checks.
     */
    public inert String*
    init_steal_trusted_utf8(String *self, char *utf8, size_t size);

    /** Return a String which wraps an external buffer containing UTF-8
     * character data after checking for validity.  The buffer must stay
     * unchanged for the lifetime of the String.
     */
    public inert incremented String*
    new_wrap_utf8(const char *utf8, size_t size);

    /** Return a String which wraps an external buffer containing UTF-8
     * character data, skipping validity checks.  The buffer must stay
     * unchanged for the lifetime of the String.
     */
    public inert incremented String*
    new_wrap_trusted_utf8(const char *utf8, size_t size);

    inert incremented String*
    init_stack_string(void *allocation, const char *utf8, size_t size);

    /** Initialize a String which wraps an external buffer containing UTF-8
     * character data after checking for validity.
     */
    public inert String*
    init_wrap_trusted_utf8(String *self, const char *utf8, size_t size);

    /** Return a String which holds a single character.
     */
    public inert incremented String*
    new_from_char(int32_t code_point);

    /** Return a String with content expanded from a pattern and arguments
     * conforming to the spec defined by CharBuf.
     *
     * Note: a user-supplied `pattern` string is a security hole
     * and must not be allowed.
     */
    public inert incremented String*
    newf(const char *pattern, ...);

    void*
    To_Host(String *self);

    /** Return the concatenation of the String and `other`.
     */
    public incremented String*
    Cat(String *self, String *other);

    /** Return the concatenation of the String and the supplied UTF-8
     * character data after checking for validity.
     */
    public incremented String*
    Cat_Utf8(String *self, const char *ptr, size_t size);

    /** Return the concatenation of the String and the supplied UTF-8
     * character data, skipping validity checks.
     */
    public incremented String*
    Cat_Trusted_Utf8(String *self, const char *ptr, size_t size);

    public int64_t
    To_I64(String *self);

    /** Extract a 64-bit integer from a variable-base stringified version.
     */
    public int64_t
    BaseX_To_I64(String *self, uint32_t base);

    public double
    To_F64(String *self);

    /** Test whether the String starts with `prefix`.
     */
    public bool
    Starts_With(String *self, String *prefix);

    /** Test whether the String starts with `prefix`.
     */
    public bool
    Starts_With_Utf8(String *self, const char *prefix, size_t size);

    /** Test whether the String ends with `suffix`.
     */
    public bool
    Ends_With(String *self, String *suffix);

    /** Test whether the String ends with `suffix`.
     */
    public bool
    Ends_With_Utf8(String *self, const char *suffix, size_t size);

    /** Test whether the String contains `substring`.
     */
    public bool
    Contains(String *self, String *substring);

    /** Test whether the String contains `substring`.
     */
    public bool
    Contains_Utf8(String *self, const char *ptr, size_t size);

    /** Return a [](StringIterator) pointing to the first occurrence of the
     * substring within the String, or [](@null) if the substring does not
     * match.
     */
    public incremented nullable StringIterator*
    Find(String *self, String *substring);

    /** Return a [](StringIterator) pointing to the first occurrence of the
     * substring within the String, or [](@null) if the substring does not
     * match.
     */
    public incremented nullable StringIterator*
    Find_Utf8(String *self, const char *ptr, size_t size);

    /** Test whether the String matches the supplied UTF-8 character data.
     */
    public bool
    Equals_Utf8(String *self, const char *ptr, size_t size);

    /** Return the number of Unicode code points the String contains.
     */
    public size_t
    Length(String *self);

    /** Return the number of bytes occupied by the String's internal content.
     */
    public size_t
    Get_Size(String *self);

    /** Return the internal backing array for the String if its internal
     * encoding is UTF-8.  If it is not encoded as UTF-8 throw an exception.
     */
    public const char*
    Get_Ptr8(String *self);

    /** Return a NULL-terminated copy of the string data in UTF-8 encoding.
     * The buffer must be freed by the caller.
     */
    public char*
    To_Utf8(String *self);

    public incremented String*
    Clone(String *self);

    bool
    Is_Copy_On_IncRef(String *self);

    public void
    Destroy(String *self);

    public bool
    Equals(String *self, Obj *other);

    public int32_t
    Compare_To(String *self, Obj *other);

    /** Return a hash code for the string.
     */
    size_t
    Hash_Sum(String *self);

    public incremented String*
    To_String(String *self);

    /** Remove Unicode whitespace characters from both top and tail.
     */
    public incremented String*
    Trim(String *self);

    /** Remove leading Unicode whitespace.
     */
    public incremented String*
    Trim_Top(String *self);

    /** Remove trailing Unicode whitespace.
     */
    public incremented String*
    Trim_Tail(String *self);

    /** Return the Unicode code point located `tick` code points in from the
     * top.  Return CFISH_STR_OOB if out of bounds.
     */
    public int32_t
    Code_Point_At(String *self, size_t tick);

    /** Return the Unicode code point located `tick` code points counting
     * backwards from the end.  Return CFISH_STR_OOB if out of bounds.
     */
    public int32_t
    Code_Point_From(String *self, size_t tick);

    /** Return a new String containing a copy of the specified substring.
     * @param offset Offset from the top, in code points.
     * @param len The desired length of the substring, in code points.
     */
    public incremented String*
    SubString(String *self, size_t offset, size_t len);

    /** Return an iterator initialized to the start of the string.
     */
    public incremented StringIterator*
    Top(String *self);

    /** Return an iterator initialized to the end of the string.
     */
    public incremented StringIterator*
    Tail(String *self);
}

public final class Clownfish::StringIterator nickname StrIter
    inherits Clownfish::Obj {

    String *string;
    size_t  byte_offset;

    inert incremented StringIterator*
    new(String *string, size_t byte_offset);

    /** Return the substring between the top and tail iterators.
     * @param top Top iterator. Use start of string if [](@null).
     * @param tail Tail iterator. Use end of string if [](@null).
     */
    public inert incremented String*
    crop(StringIterator *top, StringIterator *tail);

    public incremented StringIterator*
    Clone(StringIterator *self);

    public void
    Assign(StringIterator *self, StringIterator *other);

    public bool
    Equals(StringIterator *self, Obj *other);

    public int32_t
    Compare_To(StringIterator *self, Obj *other);

    /** Return true if the iterator is not at the end of the string.
     */
    public bool
    Has_Next(StringIterator *self);

    /** Return true if the iterator is not at the start of the string.
     */
    public bool
    Has_Prev(StringIterator *self);

    /** Return the code point after the current position and advance the
     * iterator. Return CFISH_STR_OOB at the end of the string.
     */
    public int32_t
    Next(StringIterator *self);

    /** Return the code point before the current position and go one step back.
     * Return CFISH_STR_OOB at the start of the string.
     */
    public int32_t
    Prev(StringIterator *self);

    /** Skip code points.
     * @param num The number of code points to skip.
     * @return the number of code points actually skipped. This can be less
     * than the requested number if the end of the string is reached.
     */
    public size_t
    Advance(StringIterator *self, size_t num);

    /** Skip code points backward.
     * @param num The number of code points to skip.
     * @return the number of code points actually skipped. This can be less
     * than the requested number if the start of the string is reached.
     */
    public size_t
    Recede(StringIterator *self, size_t num);

    /** Skip whitespace.
     * @return the number of code points skipped.
     */
    public size_t
    Skip_Whitespace(StringIterator *self);

    /** Skip whitespace backward.
     * @return the number of code points skipped.
     */
    public size_t
    Skip_Whitespace_Back(StringIterator *self);

    /** Test whether the content after the iterator starts with `prefix`.
     */
    public bool
    Starts_With(StringIterator *self, String *prefix);

    /** Test whether the content after the iterator starts with `prefix`.
     */
    public bool
    Starts_With_Utf8(StringIterator *self, const char *prefix, size_t size);

    /** Test whether the content before the iterator ends with
     * `suffix`.
     */
    public bool
    Ends_With(StringIterator *self, String *suffix);

    /** Test whether the content before the iterator ends with `suffix`.
     */
    public bool
    Ends_With_Utf8(StringIterator *self, const char *suffix, size_t size);

    public void
    Destroy(StringIterator *self);
}

__C__

#define CFISH_SSTR_BLANK() \
    cfish_Str_init_stack_string(CFISH_ALLOCA_OBJ(CFISH_STRING), "", 0)

#define CFISH_SSTR_WRAP_C(ptr) \
    cfish_Str_init_stack_string(CFISH_ALLOCA_OBJ(CFISH_STRING), ptr, \
                                strlen(ptr))

#define CFISH_SSTR_WRAP_UTF8(ptr, size) \
    cfish_Str_init_stack_string(CFISH_ALLOCA_OBJ(CFISH_STRING), ptr, size)

#define CFISH_STR_OOB       -1

#ifdef CFISH_USE_SHORT_NAMES
  #define SSTR_BLANK             CFISH_SSTR_BLANK
  #define SSTR_WRAP_C            CFISH_SSTR_WRAP_C
  #define SSTR_WRAP_UTF8         CFISH_SSTR_WRAP_UTF8
  #define STR_OOB                CFISH_STR_OOB
#endif
__END_C__


